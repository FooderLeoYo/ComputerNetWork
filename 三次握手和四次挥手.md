# 三次握手和四次挥手

## 目录

[三次握手](#jump1)

[四次挥手](#jump2)

[为什么TCP连接的时候是3次？2次不可以吗？](#jump3)

[为什么TCP连接的时候是3次，关闭的时候却是4次？](#jump4)

[为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？](#jump5)

---	

<span id="jump1"></span>

## 三次握手

三次握手是客户端与服务端之间的三次信息发送，本质是确认通信双方收发数据的能力

首先，我让信使运输一份信件给对方，对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。

于是他给我回信，我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以。

然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，他若收到了，他便清楚了他的发件能力和我的收件能力是可以的。

---

<span id="jump2"></span>

## 四次挥手

四次挥手是客户端与服务端之间的四次信息发送，目的是关闭一个连接

### 第一次挥手

#### 客户端告诉服务端我没有数据要发送了

当客户端的数据都传输完成后，客户端向服务端发出连接释放报文FIN

当然数据没发完时也可以发送连接释放报文并停止发送数据

客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据

### 第二次挥手

#### 服务端告诉客户端我收到你的FIN了

服务端收到客户端发的FIN报文后给客户端回复确认报文

此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文

这个状态还要持续一段时间，因为服务端可能还有数据没发完

### 第三次挥手

#### 服务端告诉客户端我没有数据要发送了

服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文

### 第四次挥手

#### 客户端告诉服务端我收到你的FIN了

客户端收到服务端发的FIN报文后，向服务端发出确认报文

注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接

而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些

---

<span id="jump3"></span>

## 为什么TCP连接的时候是3次？2次不可以吗？

因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。

---

<span id="jump4"></span>

## 为什么TCP连接的时候是3次，关闭的时候却是4次？

因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。

---

<span id="jump5"></span>

## 为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？

由于存在丢包，因此要确认服务端确实已经收到了第四次挥手报文了。如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL。即如果超过2MSL客户端未收到服务端发来的新的第三次挥手报文，则说明服务端已收到第四次挥手报文了
